
<h3 id="toc_8">Authentication and Authorization (a.k.a. Security)</h3>

<p>Now that the Angular front-end and the Spring Boot back-end are working together, let&#39;s add authentication and authorization via Spring Security. Our goal is to add users and passwords to the Spring Boot application, and to require login to access any of the API&#39;s endpoints. In the Angular app, whenever we get an HTTP 401 (Unauthorized) response code from the API, we&#39;ll present the user with a login UI, and attempt to log them in.</p>

<p>We&#39;ll be using Json Web Tokens (JWT) for authenticating the user. When the user successfully logs in, they&#39;ll be issued a token (the API will return it in a response header). The Angular app will then include this token in a header with each subsequent request. When the API sees a valid token in a request, it will respond as it does now. If the token is missing or invalid, it will again return an HTTP response with a 401 status code.</p>

<h2 id="toc_9"></h2>

<p>First, let&#39;s modify the Angular app to add a &#39;home page&#39;.
When we&#39;re finished, this will be the one part of the application that an unauthenticated user will be able to access. The rest of the application will require the user to log in.</p>

<ul>
<li>Add a new file named home.component.ts to the app/ directory, with the following code:</li>
</ul>

<div><pre class="line-numbers"><code class="language-typescript">import { Component } from &#39;@angular/core&#39;

@Component({
  moduleId: module.id,
  selector: &#39;home&#39;,
  template: `&lt;h1&gt;Welcome to the Tour of Heroes&lt;/h1&gt;`
})
export class HomeComponent {
}</code></pre></div>

<p><strong>home.component.ts</strong></p>

<p>This is a very simple component, that just displays the static text, <q>Welcome to the Tour of Heroes</q></p>

<ul>
<li><p>Modify app.module.ts to import and declare the new home component</p>

<ul>
<li>add <code>import { HomeComponent } from &#39;./home.component&#39;;</code> to the imports at the top</li>
<li>add <code>HomeComponent</code> to the declarations section of the NgModule metadata</li>
</ul></li>
<li><p>Modify app-routing.module.ts to add the HomeComponent to the app&#39;s router, making the new component the default view. Your app-routing.module.ts should now look like this:</p>

<div><pre class="line-numbers"><code class="language-typescript">import { NgModule }             from &#39;@angular/core&#39;;
import { RouterModule, Routes } from &#39;@angular/router&#39;;
import { HomeComponent}         from &#39;./home.component&#39;;
import { DashboardComponent }   from &#39;./dashboard.component&#39;;
import { HeroesComponent }      from &#39;./heroes.component&#39;;
import { HeroDetailComponent }  from &#39;./hero-detail.component&#39;;
const routes: Routes = [
{ path: &#39;&#39;, redirectTo: &#39;/home&#39;, pathMatch: &#39;full&#39; },
{ path: &#39;home&#39;,       component: HomeComponent },
{ path: &#39;dashboard&#39;,  component: DashboardComponent },
{ path: &#39;detail/:id&#39;, component: HeroDetailComponent },
{ path: &#39;heroes&#39;,     component: HeroesComponent }
];
@NgModule({
imports: [ RouterModule.forRoot(routes) ],
exports: [ RouterModule ]
})
export class AppRoutingModule {}</code></pre></div>

<p><strong>app-routing.module.ts</strong></p>

<p><code>
</code></p></li>
<li><p>Finally, modify app.component.ts to add a menu item for the &#39;Home&#39; view, so that we can get back to it after navigating to one of the other views. Your app.component.ts should now look like this:</p>

<div><pre class="line-numbers"><code class="language-typescript">import { Component } from &#39;@angular/core&#39;;

@Component({
moduleId: module.id,
selector: &#39;my-app&#39;,
template: `
&lt;h1&gt;{{title}}&lt;/h1&gt;
&lt;nav&gt;
  &lt;a routerLink=&quot;/home&quot; routerLinkActive=&quot;active&quot;&gt;Home&lt;/a&gt;
  &lt;a routerLink=&quot;/dashboard&quot; routerLinkActive=&quot;active&quot;&gt;Dashboard&lt;/a&gt;
  &lt;a routerLink=&quot;/heroes&quot; routerLinkActive=&quot;active&quot;&gt;Heroes&lt;/a&gt;
&lt;/nav&gt;
&lt;router-outlet&gt;&lt;/router-outlet&gt;
`,
styleUrls: [&#39;./app.component.css&#39;]
})
export class AppComponent {
title = &#39;Tour of Heroes&#39;;
}</code></pre></div>

<p><strong>app.component.ts</strong></p>

<p>Reload the app, and you should wind up on the new home view, and you should see a new navigation menu item for <q>Home</q>. Make sure that everything still works, including the new menu item.</p></li>
</ul>

<h2 id="toc_10"></h2>

<h3 id="toc_11">Adding Spring Security to the API</h3>

<p>To add Spring Security to the Spring Boot app, edit the build.gradle file and add the spring-boot-starter-security and io.jsonwebtoken.jjwt libraries to the dependencies. Your build.gradle file&#39;s dependency section should now look like this:</p>

<div><pre class="line-numbers"><code class="language-groovy">dependencies {
    compile(&quot;org.springframework.boot:spring-boot-starter-data-rest&quot;)
    compile(&quot;org.springframework.boot:spring-boot-starter-data-jpa&quot;)
    compile(&quot;com.h2database:h2&quot;)
    compile(&quot;org.springframework.boot:spring-boot-starter-security&quot;)
    compile(&quot;io.jsonwebtoken:jjwt:0.7.0&quot;)
    testCompile(&quot;org.springframework.boot:spring-boot-starter-test&quot;)
}</code></pre></div>

<p>If you try the application now, you&#39;ll see that all requests to the back-end result in an HTTP 401 <q>Unauthorized</q> response. By default, Spring Security secures the entire web application with &#39;basic&#39; authentication, and a single default user named &#39;user&#39; with a random password that is printed to the console on startup. If you use Postman, curl, wget, or something similar, and can set a Basic authentication header, with that user and password, you could, in theory still access the API. </p>

<p>We want real users and passwords, backed by the database, so let&#39;s proceed with setting that up.</p>

<p>Most of the spring-security-specific Java code that we&#39;re going to add next is from a very informative demo project written by Stephan Zerhusen, which is available on GitHub at <a href="https://github.com/szerhusenBC/jwt-spring-security-demo">https://github.com/szerhusenBC/jwt-spring-security-demo</a>. I&#39;m using Stephan&#39;s code here with his permission, and under the code&#39;s MIT license (Thanks, Stephan!). Stephan also has a very informative companion blog post at <a href="https://www.toptal.com/java/rest-security-with-jwt-spring-security-and-java">https://www.toptal.com/java/rest-security-with-jwt-spring-security-and-java</a>. You&#39;ll be able to tell which code is his, because I&#39;ve kept it all in one package - it&#39;s original package was <code>org.zerhusen</code> and I&#39;ve moved it to <code>heroes.org.zerhusen</code>. I moved it there to allow Spring to scan for annotations like @Configuration, @Repository, @Entity, etc. (there are other ways to achieve that, but puting everything under one root package is the simplest).</p>

<p>We have a fair amount of (Stephan&#39;s) code to add for this. I&#39;ll show it here, but if you are coding this up as you read along, it&#39;s probably easiest to just download this part of the code from my GitHub repo and paste it in.
So here it goes - create a <code>heroes.org.zerhusen</code> package, and add the following sub-packages and classes:</p>

<ul>
<li><p>Create a <q>model.security</q> package - <code>heroes.org.zerhusen.model.security</code>, and add these classes, which are the domain object for Users (people who authenticate), and Authorities (a.k.a. Roles):</p>

<ul>
<li>User:</li>
</ul>

<div><pre class="line-numbers"><code class="language-java">package heroes.org.zerhusen.model.security;

import javax.persistence.*;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import java.util.Date;
import java.util.List;

@Entity
@Table(name = &quot;USER&quot;)
public class User {

    @Id
    @Column(name = &quot;ID&quot;)
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = &quot;user_seq&quot;)
    @SequenceGenerator(name = &quot;user_seq&quot;, sequenceName = &quot;user_seq&quot;, allocationSize = 1)
    private Long id;

    @Column(name = &quot;USERNAME&quot;, length = 50, unique = true)
    @NotNull
    @Size(min = 4, max = 50)
    private String username;

    @Column(name = &quot;PASSWORD&quot;, length = 100)
    @NotNull
    @Size(min = 4, max = 100)
    private String password;

    @Column(name = &quot;FIRSTNAME&quot;, length = 50)
    @NotNull
    @Size(min = 4, max = 50)
    private String firstname;

    @Column(name = &quot;LASTNAME&quot;, length = 50)
    @NotNull
    @Size(min = 4, max = 50)
    private String lastname;

    @Column(name = &quot;EMAIL&quot;, length = 50)
    @NotNull
    @Size(min = 4, max = 50)
    private String email;

    @Column(name = &quot;ENABLED&quot;)
    @NotNull
    private Boolean enabled;

    @Column(name = &quot;LASTPASSWORDRESETDATE&quot;)
    @Temporal(TemporalType.TIMESTAMP)
    @NotNull
    private Date lastPasswordResetDate;

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(
            name = &quot;USER_AUTHORITY&quot;,
            joinColumns = {@JoinColumn(name = &quot;USER_ID&quot;, referencedColumnName = &quot;ID&quot;)},
            inverseJoinColumns = {@JoinColumn(name = &quot;AUTHORITY_ID&quot;, referencedColumnName = &quot;ID&quot;)})
    private List&lt;Authority&gt; authorities;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getFirstname() {
        return firstname;
    }

    public void setFirstname(String firstname) {
        this.firstname = firstname;
    }

    public String getLastname() {
        return lastname;
    }

    public void setLastname(String lastname) {
        this.lastname = lastname;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public Boolean getEnabled() {
        return enabled;
    }

    public void setEnabled(Boolean enabled) {
        this.enabled = enabled;
    }

    public List&lt;Authority&gt; getAuthorities() {
        return authorities;
    }

    public void setAuthorities(List&lt;Authority&gt; authorities) {
        this.authorities = authorities;
    }

    public Date getLastPasswordResetDate() {
        return lastPasswordResetDate;
    }

    public void setLastPasswordResetDate(Date lastPasswordResetDate) {
        this.lastPasswordResetDate = lastPasswordResetDate;
    }
}</code></pre></div>

<ul>
<li>AuthorityName:</li>
</ul>

<div><pre class="line-numbers"><code class="language-java">package heroes.org.zerhusen.model.security;

public enum AuthorityName {
   ROLE_USER, ROLE_ADMIN
}</code></pre></div>

<ul>
<li>Authority:</li>
</ul>

<div><pre class="line-numbers"><code class="language-java">package heroes.org.zerhusen.model.security;

import javax.persistence.*;
import javax.validation.constraints.NotNull;
import java.util.List;

@Entity
@Table(name = &quot;AUTHORITY&quot;)
public class Authority {

    @Id
    @Column(name = &quot;ID&quot;)
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = &quot;authority_seq&quot;)
    @SequenceGenerator(name = &quot;authority_seq&quot;, sequenceName = &quot;authority_seq&quot;, allocationSize = 1)
    private Long id;

    @Column(name = &quot;NAME&quot;, length = 50)
    @NotNull
    @Enumerated(EnumType.STRING)
    private AuthorityName name;

    @ManyToMany(mappedBy = &quot;authorities&quot;, fetch = FetchType.LAZY)
    private List&lt;User&gt; users;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public AuthorityName getName() {
        return name;
    }

    public void setName(AuthorityName name) {
        this.name = name;
    }

    public List&lt;User&gt; getUsers() {
        return users;
    }

    public void setUsers(List&lt;User&gt; users) {
        this.users = users;
    }
}</code></pre></div>

<h2 id="toc_12"></h2></li>
<li><p>Create a <q>security</q> package - <code>heroes.org.zerhusen.security</code>, and add these classes, which implement the generic logic generating tokens, parsing incoming tokens, and authenticating a user based on a previously generated token:</p>

<ul>
<li>JwtAuthenticationEntryPoint:</li>
</ul>

<div><pre class="line-numbers"><code class="language-java">package heroes.org.zerhusen.security;

import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.Serializable;

@Component
public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint, Serializable {

    private static final long serialVersionUID = -8970718410437077606L;

    @Override
    public void commence(HttpServletRequest request,
                         HttpServletResponse response,
                         AuthenticationException authException) throws IOException {
        // This is invoked when user tries to access a secured REST resource without supplying any credentials
        // We should just send a 401 Unauthorized response because there is no &#39;login page&#39; to redirect to
        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, &quot;Unauthorized&quot;);
    }
}</code></pre></div>

<ul>
<li>JwtAuthenticationRequest:</li>
</ul>

<div><pre class="line-numbers"><code class="language-java">package heroes.org.zerhusen.security;

import java.io.Serializable;

/**
 * Created by stephan on 20.03.16.
 */
public class  JwtAuthenticationRequest implements Serializable {

    private static final long serialVersionUID = -8445943548965154778L;

    private String username;
    private String password;

    public JwtAuthenticationRequest() {
        super();
    }

    public JwtAuthenticationRequest(String username, String password) {
        this.setUsername(username);
        this.setPassword(password);
    }

    public String getUsername() {
        return this.username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return this.password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}</code></pre></div>

<ul>
<li>JwtAuthenticationTokenFilter:</li>
</ul>

<div><pre class="line-numbers"><code class="language-java">package heroes.org.zerhusen.security;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {

    private final Log logger = LogFactory.getLog(this.getClass());

    @Autowired
    private UserDetailsService userDetailsService;

    @Autowired
    private JwtTokenUtil jwtTokenUtil;

    @Value(&quot;${jwt.header}&quot;)
    private String tokenHeader;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException {
        String authToken = request.getHeader(this.tokenHeader);

        if(authToken != null &amp;&amp; authToken.startsWith(&quot;Bearer &quot;)) {
            authToken = authToken.substring(7);
        }

        String username = jwtTokenUtil.getUsernameFromToken(authToken);

        logger.info(&quot;checking authentication für user &quot; + username);

        if (username != null &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null) {

            // It is not compelling necessary to load the use details from the database. You could also store the information
            // in the token and read it from it. It&#39;s up to you ;)
            UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);

            // For simple validation it is completely sufficient to just check the token integrity. You don&#39;t have to call
            // the database compellingly. Again it&#39;s up to you ;)
            if (jwtTokenUtil.validateToken(authToken, userDetails)) {
                UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                logger.info(&quot;authenticated user &quot; + username + &quot;, setting security context&quot;);
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        }

        chain.doFilter(request, response);
    }
}</code></pre></div>

<blockquote>
<p>Note that I made one change to Stephan&#39;s code in the JwtAuthenticationTokenFilter class - the original code used the entire value of the HTTP authorization header. However, while not required, it is common practice for the client to form the header by prepending the word <q>Bearer</q> to the actual token, to explicitly indicate that it is a <q>Bearer Token</q>.
So, I added the code to strip off the prefix before attempting to parse the token.  </p>
</blockquote>

<h2 id="toc_13"></h2>

<ul>
<li>JwtTokenUtil:<br></li>
</ul>

<div><pre class="line-numbers"><code class="language-java">package heroes.org.zerhusen.security;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.mobile.device.Device;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import java.io.Serializable;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

@Component
public class JwtTokenUtil implements Serializable {

    private static final long serialVersionUID = -3301605591108950415L;

    static final String CLAIM_KEY_USERNAME = &quot;sub&quot;;
    static final String CLAIM_KEY_AUDIENCE = &quot;audience&quot;;
    static final String CLAIM_KEY_CREATED = &quot;created&quot;;

    private static final String AUDIENCE_UNKNOWN = &quot;unknown&quot;;
    private static final String AUDIENCE_WEB = &quot;web&quot;;
    private static final String AUDIENCE_MOBILE = &quot;mobile&quot;;
    private static final String AUDIENCE_TABLET = &quot;tablet&quot;;

    @Value(&quot;${jwt.secret}&quot;)
    private String secret;

    @Value(&quot;${jwt.expiration}&quot;)
    private Long expiration;

    public String getUsernameFromToken(String token) {
        String username;
        try {
            final Claims claims = getClaimsFromToken(token);
            username = claims.getSubject();
        } catch (Exception e) {
            username = null;
        }
        return username;
    }

    public Date getCreatedDateFromToken(String token) {
        Date created;
        try {
            final Claims claims = getClaimsFromToken(token);
            created = new Date((Long) claims.get(CLAIM_KEY_CREATED));
        } catch (Exception e) {
            created = null;
        }
        return created;
    }

    public Date getExpirationDateFromToken(String token) {
        Date expiration;
        try {
            final Claims claims = getClaimsFromToken(token);
            expiration = claims.getExpiration();
        } catch (Exception e) {
            expiration = null;
        }
        return expiration;
    }

    public String getAudienceFromToken(String token) {
        String audience;
        try {
            final Claims claims = getClaimsFromToken(token);
            audience = (String) claims.get(CLAIM_KEY_AUDIENCE);
        } catch (Exception e) {
            audience = null;
        }
        return audience;
    }

    private Claims getClaimsFromToken(String token) {
        Claims claims;
        try {
            claims = Jwts.parser()
                    .setSigningKey(secret)
                    .parseClaimsJws(token)
                    .getBody();
        } catch (Exception e) {
            claims = null;
        }
        return claims;
    }

    private Date generateExpirationDate() {
        return new Date(System.currentTimeMillis() + expiration * 1000);
    }

    private Boolean isTokenExpired(String token) {
        final Date expiration = getExpirationDateFromToken(token);
        return expiration.before(new Date());
    }

    private Boolean isCreatedBeforeLastPasswordReset(Date created, Date lastPasswordReset) {
        return (lastPasswordReset != null &amp;&amp; created.before(lastPasswordReset));
    }

    private String generateAudience(Device device) {
        String audience = AUDIENCE_UNKNOWN;
        if (device.isNormal()) {
            audience = AUDIENCE_WEB;
        } else if (device.isTablet()) {
            audience = AUDIENCE_TABLET;
        } else if (device.isMobile()) {
            audience = AUDIENCE_MOBILE;
        }
        return audience;
    }

    private Boolean ignoreTokenExpiration(String token) {
        String audience = getAudienceFromToken(token);
        return (AUDIENCE_TABLET.equals(audience) || AUDIENCE_MOBILE.equals(audience));
    }

    public String generateToken(UserDetails userDetails, Device device) {
        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();
        claims.put(CLAIM_KEY_USERNAME, userDetails.getUsername());
        claims.put(CLAIM_KEY_AUDIENCE, generateAudience(device));
        claims.put(CLAIM_KEY_CREATED, new Date());
        return generateToken(claims);
    }

    String generateToken(Map&lt;String, Object&gt; claims) {
        return Jwts.builder()
                .setClaims(claims)
                .setExpiration(generateExpirationDate())
                .signWith(SignatureAlgorithm.HS512, secret)
                .compact();
    }

    public Boolean canTokenBeRefreshed(String token, Date lastPasswordReset) {
        final Date created = getCreatedDateFromToken(token);
        return !isCreatedBeforeLastPasswordReset(created, lastPasswordReset)
                &amp;&amp; (!isTokenExpired(token) || ignoreTokenExpiration(token));
    }

    public String refreshToken(String token) {
        String refreshedToken;
        try {
            final Claims claims = getClaimsFromToken(token);
            claims.put(CLAIM_KEY_CREATED, new Date());
            refreshedToken = generateToken(claims);
        } catch (Exception e) {
            refreshedToken = null;
        }
        return refreshedToken;
    }

    public Boolean validateToken(String token, UserDetails userDetails) {
        JwtUser user = (JwtUser) userDetails;
        final String username = getUsernameFromToken(token);
        final Date created = getCreatedDateFromToken(token);
        //final Date expiration = getExpirationDateFromToken(token);
        return (
                username.equals(user.getUsername())
                        &amp;&amp; !isTokenExpired(token)
                        &amp;&amp; !isCreatedBeforeLastPasswordReset(created, user.getLastPasswordResetDate()));
    }
}  </code></pre></div>

<ul>
<li>JwtUser:<br></li>
</ul>

<div><pre class="line-numbers"><code class="language-java">package heroes.org.zerhusen.security;

import com.fasterxml.jackson.annotation.JsonIgnore;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.Date;

/**
 * Created by stephan on 20.03.16.
 */
public class JwtUser implements UserDetails {

    private final Long id;
    private final String username;
    private final String firstname;
    private final String lastname;
    private final String password;
    private final String email;
    private final Collection&lt;? extends GrantedAuthority&gt; authorities;
    private final boolean enabled;
    private final Date lastPasswordResetDate;

    public JwtUser(
          Long id,
          String username,
          String firstname,
          String lastname,
          String email,
          String password, Collection&lt;? extends GrantedAuthority&gt; authorities,
          boolean enabled,
          Date lastPasswordResetDate
    ) {
        this.id = id;
        this.username = username;
        this.firstname = firstname;
        this.lastname = lastname;
        this.email = email;
        this.password = password;
        this.authorities = authorities;
        this.enabled = enabled;
        this.lastPasswordResetDate = lastPasswordResetDate;
    }

    @JsonIgnore
    public Long getId() {
        return id;
    }

    @Override
    public String getUsername() {
        return username;
    }

    @JsonIgnore
    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @JsonIgnore
    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @JsonIgnore
    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    public String getFirstname() {
        return firstname;
    }

    public String getLastname() {
        return lastname;
    }

    public String getEmail() {
        return email;
    }

    @JsonIgnore
    @Override
    public String getPassword() {
        return password;
    }

    @Override
    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {
        return authorities;
    }

    @Override
    public boolean isEnabled() {
        return enabled;
    }

    @JsonIgnore
    public Date getLastPasswordResetDate() {
        return lastPasswordResetDate;
    }
}
</code></pre></div>

<ul>
<li>JwtUserFactory:<br></li>
</ul>

<div><pre class="line-numbers"><code class="language-java">package heroes.org.zerhusen.security;

import heroes.org.zerhusen.model.security.Authority;
import heroes.org.zerhusen.model.security.User;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;

import java.util.List;
import java.util.stream.Collectors;

public final class JwtUserFactory {

    private JwtUserFactory() {
    }

    public static JwtUser create(User user) {
        return new JwtUser(
                user.getId(),
                user.getUsername(),
                user.getFirstname(),
                user.getLastname(),
                user.getEmail(),
                user.getPassword(),
                mapToGrantedAuthorities(user.getAuthorities()),
                user.getEnabled(),
                user.getLastPasswordResetDate()
        );
    }

    private static List&lt;GrantedAuthority&gt; mapToGrantedAuthorities(List&lt;Authority&gt; authorities) {
        return authorities.stream()
                .map(authority -&gt; new SimpleGrantedAuthority(authority.getName().name()))
                .collect(Collectors.toList());
    }
}
</code></pre></div>

<h2 id="toc_14"></h2></li>
<li><p>Under the <q>security</q> package, create a <q>repository</q> package - <code>heroes.org.zerhusen.security.repository</code>, and add the following UserRepository interface, which will be responsible for retrieving Users from the database by their login name:</p>

<div><pre class="line-numbers"><code class="language-java">package heroes.org.zerhusen.security.repository;

import heroes.org.zerhusen.model.security.User;
import org.springframework.data.jpa.repository.JpaRepository;

/**
 * Created by stephan on 20.03.16.
 */
@RepositoryRestResource(exported = false)
public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
    User findByUsername(String username);
}  </code></pre></div>

<blockquote>
<p>I added the @RepositoryRestResource annotation to tell Spring to not expose Users to the REST interface - if you&#39;re going to create a User management interface (which we&#39;re not doing here), you will have to either remove the &#39;exported&#39; argument from the annotation, or set it&#39;s value to &#39;true&#39;, to again expose the User repository to the REST API.</p>
</blockquote>

<h2 id="toc_15"></h2></li>
<li><p>Under the <q>security</q> package, create a <q>service</q> package - <code>heroes.org.zerhusen.security.service</code>, and add the following classes, which will implement the service layer for getting a user by name from the UserRespository:</p>

<ul>
<li>JwtUserDetailsServiceImpl:</li>
</ul>

<div><pre class="line-numbers"><code class="language-java">package heroes.org.zerhusen.security.service;

import heroes.org.zerhusen.model.security.User;
import heroes.org.zerhusen.security.JwtUserFactory;
import heroes.org.zerhusen.security.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

/**
 * Created by stephan on 20.03.16.
 */
@Service
public class JwtUserDetailsServiceImpl implements UserDetailsService {

    @Autowired
    private UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username);

        if (user == null) {
            throw new UsernameNotFoundException(String.format(&quot;No user found with username &#39;%s&#39;.&quot;, username));
        } else {
            return JwtUserFactory.create(user);
        }
    }
}</code></pre></div>

<ul>
<li>JwtAuthenticationResponse:</li>
</ul>

<div><pre class="line-numbers"><code class="language-java">package heroes.org.zerhusen.security.service;

import java.io.Serializable;

/**
 * Created by stephan on 20.03.16.
 */
public class JwtAuthenticationResponse implements Serializable {

    private static final long serialVersionUID = 1250166508152483573L;

    private final String token;

    public JwtAuthenticationResponse(String token) {
        this.token = token;
    }

    public String getToken() {
        return this.token;
    }
}  </code></pre></div>

<h2 id="toc_16"></h2></li>
<li><p>Under the <q>security</q> package, create a <q>controller</q> package - <code>heroes.org.zerhusen.security.controller</code>, and add the AuthenticationRestController class, which will be the Controller responsible for handling login requests:</p></li>
</ul>

<div><pre class="line-numbers"><code class="language-java">    package heroes.org.zerhusen.security.controller;

    import heroes.org.zerhusen.security.JwtAuthenticationRequest;
    import heroes.org.zerhusen.security.JwtUser;
    import heroes.org.zerhusen.security.service.JwtAuthenticationResponse;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.beans.factory.annotation.Value;
    import org.springframework.http.ResponseEntity;
    import org.springframework.mobile.device.Device;
    import org.springframework.security.authentication.AuthenticationManager;
    import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
    import org.springframework.security.core.Authentication;
    import org.springframework.security.core.AuthenticationException;
    import org.springframework.security.core.context.SecurityContextHolder;
    import org.springframework.security.core.userdetails.UserDetails;
    import org.springframework.security.core.userdetails.UserDetailsService;
    import org.springframework.web.bind.annotation.RequestBody;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RequestMethod;
    import org.springframework.web.bind.annotation.RestController;
    import heroes.org.zerhusen.security.JwtTokenUtil;

    import javax.servlet.http.HttpServletRequest;

    @RestController
    public class AuthenticationRestController {

        @Value(&quot;${jwt.header}&quot;)
        private String tokenHeader;

        @Autowired
        private AuthenticationManager authenticationManager;

        @Autowired
        private JwtTokenUtil jwtTokenUtil;

        @Autowired
        private UserDetailsService userDetailsService;

        @RequestMapping(value = &quot;${jwt.route.authentication.path}&quot;, method = RequestMethod.POST)
        public ResponseEntity&lt;?&gt; createAuthenticationToken(@RequestBody JwtAuthenticationRequest authenticationRequest, Device device) throws AuthenticationException {

            // Perform the security
            final Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(
                            authenticationRequest.getUsername(),
                            authenticationRequest.getPassword()
                    )
            );
            SecurityContextHolder.getContext().setAuthentication(authentication);

            // Reload password post-security so we can generate token
            final UserDetails userDetails = userDetailsService.loadUserByUsername(authenticationRequest.getUsername());
            final String token = jwtTokenUtil.generateToken(userDetails, device);

            // Return the token
            return ResponseEntity.ok(new JwtAuthenticationResponse(token));
        }

        @RequestMapping(value = &quot;${jwt.route.authentication.refresh}&quot;, method = RequestMethod.GET)
        public ResponseEntity&lt;?&gt; refreshAndGetAuthenticationToken(HttpServletRequest request) {
            String token = request.getHeader(tokenHeader);
            String username = jwtTokenUtil.getUsernameFromToken(token);
            JwtUser user = (JwtUser) userDetailsService.loadUserByUsername(username);

            if (jwtTokenUtil.canTokenBeRefreshed(token, user.getLastPasswordResetDate())) {
                String refreshedToken = jwtTokenUtil.refreshToken(token);
                return ResponseEntity.ok(new JwtAuthenticationResponse(refreshedToken));
            } else {
                return ResponseEntity.badRequest().body(null);
            }
        }

    }</code></pre></div>

<h2 id="toc_17"></h2>

<p>Ok, that&#39;s most of the Java code - we just have one more Java configuration class and couple of other configuration files to set up.</p>

<ul>
<li>Under the <q>heroes.org.zerhusen</q> package, create a <q>config</q> package - `heroes.org.zerhusen.config&quot;, and add the following WebSecurityConfig class:</li>
</ul>

<div><pre class="line-numbers"><code class="language-java">package heroes.org.zerhusen.config;

import heroes.org.zerhusen.security.JwtAuthenticationTokenFilter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import heroes.org.zerhusen.security.JwtAuthenticationEntryPoint;

@SuppressWarnings(&quot;SpringJavaAutowiringInspection&quot;)
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private JwtAuthenticationEntryPoint unauthorizedHandler;

    @Autowired
    private UserDetailsService userDetailsService;

    @Autowired
    public void configureAuthentication(AuthenticationManagerBuilder authenticationManagerBuilder) throws Exception {
        authenticationManagerBuilder
                .userDetailsService(this.userDetailsService)
                .passwordEncoder(passwordEncoder());
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public JwtAuthenticationTokenFilter authenticationTokenFilterBean() throws Exception {
        return new JwtAuthenticationTokenFilter();
    }

    @Override
    protected void configure(HttpSecurity httpSecurity) throws Exception {
        httpSecurity
                // we don&#39;t need CSRF because our token is invulnerable
                .csrf().disable()

                .exceptionHandling().authenticationEntryPoint(unauthorizedHandler).and()

                // don&#39;t create session
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()

                .authorizeRequests()
                .antMatchers(&quot;/auth/**&quot;).permitAll()
                .antMatchers(HttpMethod.OPTIONS, &quot;/**&quot;).permitAll()
                .anyRequest().authenticated();

        // Custom JWT based security filter
        httpSecurity
                .addFilterBefore(authenticationTokenFilterBean(), UsernamePasswordAuthenticationFilter.class);

        // disable page caching
        httpSecurity.headers().cacheControl();
    }
}</code></pre></div>

<blockquote>
<p>As you can see, we&#39;re allowing authenticated users (regardless of role) to access all API endpoints. In a real application, you would probably be a bit more selective.</p>

<p>We&#39;re also allowing unauthenticated users to send OPTIONS requests to all endpoints. This is because the the browser (not our code) is responsible for sending the OPTIONS request during the pre-flight phase of an API call, and there is no way to have the browser include the authentication token. If we don&#39;t do this, the pre-flight OPTIONS request will get a 401 response, and our call will fail.</p>
</blockquote>

<p>We used some SpEL (Spring Expression Language) variables in a few places in the JwtAuthenticationFilter, and we need to define those now. So add an <q>application.yml</q> file to /src/main/resources, with the following content:</p>

<div><pre class="line-numbers"><code class="language-yml">jwt:
  header: Authorization
  secret: mySecret
  expiration: 604800
  route:
    authentication:
      path: auth
      refresh: refresh</code></pre></div>

<p>And finally, let&#39;s add some users to the database on app startup, by adding the following to the bottom of /src/main/resources/data.sql:</p>

<div><pre class="line-numbers"><code class="language-sql">INSERT INTO USER (ID, USERNAME, PASSWORD, FIRSTNAME, LASTNAME, EMAIL, ENABLED, LASTPASSWORDRESETDATE) VALUES (1, &#39;admin&#39;, &#39;$2a$08$lDnHPz7eUkSi6ao14Twuau08mzhWrL4kyZGGU5xfiGALO/Vxd5DOi&#39;, &#39;admin&#39;, &#39;admin&#39;, &#39;admin@admin.com&#39;, 1, PARSEDATETIME(&#39;01-01-2016&#39;, &#39;dd-MM-yyyy&#39;));
INSERT INTO USER (ID, USERNAME, PASSWORD, FIRSTNAME, LASTNAME, EMAIL, ENABLED, LASTPASSWORDRESETDATE) VALUES (2, &#39;user&#39;, &#39;$2a$08$UkVvwpULis18S19S5pZFn.YHPZt3oaqHZnDwqbCW9pft6uFtkXKDC&#39;, &#39;user&#39;, &#39;user&#39;, &#39;enabled@user.com&#39;, 1, PARSEDATETIME(&#39;01-01-2016&#39;,&#39;dd-MM-yyyy&#39;));
INSERT INTO USER (ID, USERNAME, PASSWORD, FIRSTNAME, LASTNAME, EMAIL, ENABLED, LASTPASSWORDRESETDATE) VALUES (3, &#39;disabled&#39;, &#39;$2a$08$UkVvwpULis18S19S5pZFn.YHPZt3oaqHZnDwqbCW9pft6uFtkXKDC&#39;, &#39;user&#39;, &#39;user&#39;, &#39;disabled@user.com&#39;, 0, PARSEDATETIME(&#39;01-01-2016&#39;,&#39;dd-MM-yyyy&#39;));

INSERT INTO AUTHORITY (ID, NAME) VALUES (1, &#39;ROLE_USER&#39;);
INSERT INTO AUTHORITY (ID, NAME) VALUES (2, &#39;ROLE_ADMIN&#39;);

INSERT INTO USER_AUTHORITY (USER_ID, AUTHORITY_ID) VALUES (1, 1);
INSERT INTO USER_AUTHORITY (USER_ID, AUTHORITY_ID) VALUES (1, 2);
INSERT INTO USER_AUTHORITY (USER_ID, AUTHORITY_ID) VALUES (2, 1);
INSERT INTO USER_AUTHORITY (USER_ID, AUTHORITY_ID) VALUES (3, 1);</code></pre></div>

<h2 id="toc_18"></h2>

<p>We haven&#39;t modified the Angular app to log in and get and present tokens yet, but we can test out our back-end changes by using Postman (or curl, or wget, or whatever your favorite tool is).</p>

<p>Fire up the back-end app, and then try to log in by POSTing to <a href="http://localhost:8080/auth">http://localhost:8080/auth</a>, with a body containing</p>

<div><pre class="line-numbers"><code class="language-javascript">{
  &quot;username&quot;: &quot;admin&quot;,
  &quot;password&quot;: &quot;admin&quot;
}</code></pre></div>

<p>and a &#39;content-type&#39; header of &#39;application/json&#39;</p>

<p>For curl, that would be </p>

<div><pre class="line-numbers"><code class="language-bash">curl --request POST \
&gt; --url http://localhost:8080/auth \
&gt; --header &#39;content-type: application/json&#39; \
&gt; --data &#39;{&quot;username&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;admin&quot;}&#39;</code></pre></div>

<p>You should get a response with a token, that looks something like this:</p>

<div><pre class="line-numbers"><code class="language-javascript">{
  &quot;token&quot; : &quot;eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZGllbmNlIjoid2ViIiwiY3JlYXRlZCI6MTQ4NTIwNzE5ODMxMCwiZXhwIjoxNDg1ODExOTk4fQ.hx-a1MT6tgG8NXFC26wMcimza53Le5FBPZKyiFmWvwvdBnDbHjalP2rLy8aSlxQDO8mW10NyJ2nQPVS4sLGspQ&quot;
}</code></pre></div>

<p>This means that you have successfully  authenticated with the back-end, and you now have your Json Web Token (JWT) to prove your identity.</p>

<p>Let&#39;s use this token to make a call to the API.
Again, using Postman, curl, or your favorite tool, send a GET request to <a href="http://localhost:8080/heroes">http://localhost:8080/heroes</a> with a header with the name <code>Authorization</code> and a value of <code>Bearer ey....</code> but with the second part replaced by the value of the token that you got in the previous step. </p>

<blockquote>
<p>If you are using Postman, you can&#39;t use the <q>Authorization</q> tab to set the authorization header, because Postman (as of version 4.9.2) doesn&#39;t support Bearer Tokens there. You&#39;ll have to use the Headers tab and create your own Authorization header.</p>
</blockquote>

<p>For curl, the request is</p>

<div><pre class="line-numbers"><code class="language-bash">curl -X GET -H &quot;Authorization: Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZGllbmNlIjoid2ViIiwiY3JlYXRlZCI6MTQ4NTIwNzE5ODMxMCwiZXhwIjoxNDg1ODExOTk4fQ.hx-a1MT6tgG8NXFC26wMcimza53Le5FBPZKyiFmWvwvdBnDbHjalP2rLy8aSlxQDO8mW10NyJ2nQPVS4sLGspQ&quot; &quot;http://localhost:8080/heroes/&quot;</code></pre></div>

<p>but again, with the token value replaced with your token.</p>

<p>You should get a JSON response containing the list of Heroes. If you don&#39;t, go back and check your code, and make sure that it works before you proceed any farther.</p>

<h2 id="toc_19"></h2>

<h3 id="toc_20">Adding Log-in and Authentication by JWT to the Angular front-end</h3>

<p>On the front-end, we&#39;re going to do our best to keep the user from trying to access back-end services when they are not logged in, but will also fall back to presenting a login UI if we do happen to get a 401 Unauthorized response from the API.</p>

<p>First, let&#39;s create the login component. </p>

<p>Here is the template for the component. Add it to the Angular app as app/login.component.html:</p>

<div><pre class="line-numbers"><code class="language-markup">&lt;div class=&quot;col-md-6 col-md-offset-3&quot;&gt;
    &lt;h2&gt;Login&lt;/h2&gt;

    &lt;div class=&quot;alert alert-info&quot;&gt;
        Username: admin&lt;br/&gt;
        Password: admin
    &lt;/div&gt;

    &lt;form name=&quot;form&quot; (ngSubmit)=&quot;f.form.valid &amp;&amp; login()&quot; #f=&quot;ngForm&quot; novalidate&gt;
        &lt;div class=&quot;form-group&quot; [ngClass]=&quot;{ &#39;has-error&#39;: f.submitted &amp;&amp; !username.valid }&quot;&gt;
            &lt;label for=&quot;username&quot;&gt;Username&lt;/label&gt;
            &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;username&quot; [(ngModel)]=&quot;model.username&quot; #username=&quot;ngModel&quot; required /&gt;
            &lt;span *ngIf=&quot;f.submitted &amp;&amp; !username.valid&quot; class=&quot;help-block&quot;&gt;Username is required&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class=&quot;form-group&quot; [ngClass]=&quot;{ &#39;has-error&#39;: f.submitted &amp;&amp; !password.valid }&quot;&gt;
            &lt;label for=&quot;password&quot;&gt;Password&amp;nbsp;&lt;/label&gt;
            &lt;input type=&quot;password&quot; class=&quot;form-control&quot; name=&quot;password&quot; [(ngModel)]=&quot;model.password&quot; #password=&quot;ngModel&quot; required /&gt;
            &lt;span *ngIf=&quot;f.submitted &amp;&amp; !password.valid&quot; class=&quot;help-block&quot;&gt;Password is required&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;button [disabled]=&quot;loading&quot; class=&quot;btn btn-primary&quot;&gt;Login&lt;/button&gt;
            &lt;img *ngIf=&quot;loading&quot; src=&quot;data:image/gif;base64,R0lGODlhEAAQAPIAAP///wAAAMLCwkJCQgAAAGJiYoKCgpKSkiH/C05FVFNDQVBFMi4wAwEAAAAh/hpDcmVhdGVkIHdpdGggYWpheGxvYWQuaW5mbwAh+QQJCgAAACwAAAAAEAAQAAADMwi63P4wyklrE2MIOggZnAdOmGYJRbExwroUmcG2LmDEwnHQLVsYOd2mBzkYDAdKa+dIAAAh+QQJCgAAACwAAAAAEAAQAAADNAi63P5OjCEgG4QMu7DmikRxQlFUYDEZIGBMRVsaqHwctXXf7WEYB4Ag1xjihkMZsiUkKhIAIfkECQoAAAAsAAAAABAAEAAAAzYIujIjK8pByJDMlFYvBoVjHA70GU7xSUJhmKtwHPAKzLO9HMaoKwJZ7Rf8AYPDDzKpZBqfvwQAIfkECQoAAAAsAAAAABAAEAAAAzMIumIlK8oyhpHsnFZfhYumCYUhDAQxRIdhHBGqRoKw0R8DYlJd8z0fMDgsGo/IpHI5TAAAIfkECQoAAAAsAAAAABAAEAAAAzIIunInK0rnZBTwGPNMgQwmdsNgXGJUlIWEuR5oWUIpz8pAEAMe6TwfwyYsGo/IpFKSAAAh+QQJCgAAACwAAAAAEAAQAAADMwi6IMKQORfjdOe82p4wGccc4CEuQradylesojEMBgsUc2G7sDX3lQGBMLAJibufbSlKAAAh+QQJCgAAACwAAAAAEAAQAAADMgi63P7wCRHZnFVdmgHu2nFwlWCI3WGc3TSWhUFGxTAUkGCbtgENBMJAEJsxgMLWzpEAACH5BAkKAAAALAAAAAAQABAAAAMyCLrc/jDKSatlQtScKdceCAjDII7HcQ4EMTCpyrCuUBjCYRgHVtqlAiB1YhiCnlsRkAAAOwAAAAAAAAAAAA==&quot; /&gt;
        &lt;/div&gt;
        &lt;div *ngIf=&quot;error&quot; class=&quot;alert alert-error&quot;&gt;{{error}}&lt;/div&gt;
    &lt;/form&gt;
&lt;/div&gt;</code></pre></div>

<p>Here is the css for the login component. Add it as app/login.component.css:</p>

<div><pre class="line-numbers"><code class="language-css">.alert {
  width:200px;
  margin-top:20px;
  margin-bottom:20px;
}

.alert.alert-info {
  color:#607D8B;
}

.alert.alert-error {
  color:red;
}

.help-block {
  width:200px;
  color:white;
  background-color:gray;
}

.form-control {
  width: 200px;
  margin-bottom:10px;
}

.btn {
  margin-top:20px;
}</code></pre></div>

<p>Here is the code for the login component. Add it as app/login.component.ts:</p>

<div><pre class="line-numbers"><code class="language-typescript">import { Component, OnInit } from &#39;@angular/core&#39;;
import { Router } from &#39;@angular/router&#39;;

import { AuthenticationService } from &#39;./authentication.service&#39;;

@Component({
    moduleId: module.id,
    templateUrl: &#39;login.component.html&#39;,
    styleUrls: [&#39;login.component.css&#39;]
})

export class LoginComponent implements OnInit {
    model: any = {};
    loading = false;
    error = &#39;&#39;;

    constructor(
        private router: Router,
        private authenticationService: AuthenticationService) { }

    ngOnInit() {
        // reset login status
        this.authenticationService.logout();
    }

    login() {
        this.loading = true;
        this.authenticationService.login(this.model.username, this.model.password)
            .subscribe(result =&gt; {
                if (result === true) {
                    // login successful
                    this.router.navigate([&#39;home&#39;]);
                } else {
                    // login failed
                    this.error = &#39;Username or password is incorrect&#39;;
                    this.loading = false;
                }
            }, error =&gt; {
              this.loading = false;
              this.error = error;
            });
    }
}</code></pre></div>

<p>The login component presents inputs for username and password, and when the &#39;Login&#39; button is clicked, calls the <code>login</code> function of the AuthenticationService (which we haven&#39;t written yet). If the login succeeds, the login component navigates to the home page. If the login fails, it displays an error message.</p>

<p>Now, we need to add the AuthenticationService, in app/authentication.service.ts:</p>

<div><pre class="line-numbers"><code class="language-typescript">import { Injectable } from &#39;@angular/core&#39;;
import { Http, Headers, Response } from &#39;@angular/http&#39;;
import { Observable } from &#39;rxjs/Rx&#39;;
import &#39;rxjs/add/operator/map&#39;;
import &#39;rxjs/add/operator/catch&#39;;
import &#39;rxjs/add/observable/throw&#39;;

@Injectable()
export class AuthenticationService {
    private authUrl = &#39;http://localhost:8080/auth&#39;;
    private headers = new Headers({&#39;Content-Type&#39;: &#39;application/json&#39;});

    constructor(private http: Http) {
    }

    login(username: string, password: string): Observable&lt;boolean&gt; {
        return this.http.post(this.authUrl, JSON.stringify({username: username, password: password}), {headers: this.headers})
            .map((response: Response) =&gt; {
                // login successful if there&#39;s a jwt token in the response
                let token = response.json() &amp;&amp; response.json().token;
                if (token) {
                    // store username and jwt token in local storage to keep user logged in between page refreshes
                    localStorage.setItem(&#39;currentUser&#39;, JSON.stringify({ username: username, token: token }));

                    // return true to indicate successful login
                    return true;
                } else {
                    // return false to indicate failed login
                    return false;
                }
            }).catch((error:any) =&gt; Observable.throw(error.json().error || &#39;Server error&#39;));
    }

    getToken(): String {
      var currentUser = JSON.parse(localStorage.getItem(&#39;currentUser&#39;));
      var token = currentUser &amp;&amp; currentUser.token;
      return token ? token : &quot;&quot;;
    }

    logout(): void {
        // clear token remove user from local storage to log user out
        localStorage.removeItem(&#39;currentUser&#39;);
    }
}
</code></pre></div>

<p>Now, in app.module.ts, import the LoginComponent and the AuthenticationService, add the LoginComponent to the @NgModule&#39;s imports section, and add the AuthenticationService to the @NgModule&#39;s providers section.</p>

<p>Your app.module.ts should look like this:</p>

<div><pre class="line-numbers"><code class="language-typescript">import &#39;./rxjs-extensions&#39;;

import { NgModule }      from &#39;@angular/core&#39;;
import { BrowserModule } from &#39;@angular/platform-browser&#39;;
import { FormsModule } from &#39;@angular/forms&#39;;
import { HttpModule } from &#39;@angular/http&#39;;

import {AppRoutingModule} from &quot;./app-routing.module&quot;;

import { AppComponent }  from &#39;./app.component&#39;;
import { HomeComponent } from &#39;./home.component&#39;;
import { LoginComponent } from &#39;./login.component&#39;;
import { DashboardComponent } from &#39;./dashboard.component&#39;;
import { HeroesComponent } from &#39;./heroes.component&#39;;
import { HeroDetailComponent } from &#39;./hero-detail.component&#39;;
import { HeroService } from &#39;./hero.service&#39;;
import { HeroSearchComponent } from &#39;./hero-search.component&#39;;
import { AuthenticationService } from &#39;./authentication.service&#39;;


@NgModule({
  imports:      [
    BrowserModule,
      FormsModule,
    HttpModule,
    AppRoutingModule
  ],
  declarations: [
    AppComponent,
    HomeComponent,
    LoginComponent,
    DashboardComponent,
      HeroDetailComponent,
    HeroesComponent,
    HeroSearchComponent
  ],
  providers: [ HeroService, AuthenticationService ],
  bootstrap: [ AppComponent ]
})
export class AppModule {
}</code></pre></div>

<p>We need to add the path to the login component to the router - modify app-routing.module.ts, and add a route for /login, pointing to the LoginComponent.</p>

<p>We&#39;ll also add a link to the menu to get to the new login component - modify app.component.ts and add a RouterLink to /login</p>

<p>You should now see the new login menu item when you start up the app, and clicking the login menu item should take you to the login page. If you login with admin / admin, and watch the network tab in the browser&#39;s developer&#39;s tools, you should see that the authentication request is posted, and that a token is returned. The app should then display the home component.</p>

<p>After you have successfully logged in and returned to the home component, you can verify that the JWT token is stored in the browser&#39;s localStorage. Go to the browser&#39;s console, and type in <code>localStorage.getItem(&quot;currentUser&quot;)</code>. You should get back a JSON string containing the user&#39;s name and the JWT token.</p>

<h3 id="toc_21">Using the JWT Token</h3>

<p>Now that we have a valid token, let&#39;s make use of it. We need to give the hero service access to the token, so that it can include it in an authorization header when it makes api requests. We could access it directly from localStorage, but it&#39;s a much better idea to encapsulate access to the token in the Authentication service, and then inject the Authentication service into the hero service.</p>

<p>Modify hero.service.ts:</p>

<ul>
<li>import the AuthenticationService</li>
<li>add the AuthenticationService to the constructor parameters</li>
<li>modify the <q>headers</q> map to include the Authorization header with the Bearer token</li>
<li>modify the getHeroes() function to use the headers</li>
</ul>

<p>Your hero.service.ts should now look like this:</p>

<div><pre class="line-numbers"><code class="language-typescript">import { Injectable } from &#39;@angular/core&#39;;
import { Headers, Http } from &quot;@angular/http&quot;;
import { AuthenticationService } from &#39;./authentication.service&#39;;
import &#39;rxjs/add/operator/toPromise&#39;;

import { Hero } from &#39;./hero&#39;

@Injectable()
export class HeroService {

  private heroesUrl = &#39;http://localhost:8080/heroes&#39;;

  private headers = new Headers({
     &#39;Content-Type&#39;: &#39;application/json&#39;,
     &#39;Authorization&#39;: &#39;Bearer &#39; + this.authenticationService.getToken()
     });

  constructor(
    private http: Http,
    private authenticationService: AuthenticationService) {
  }

  getHeroes(): Promise&lt;Hero[]&gt; {
     return this.http
      .get(this.heroesUrl, {headers: this.headers})
      .toPromise()
      .then(response =&gt; response.json()._embedded.heroes as Hero[])
      .catch(this.handleError);

  }

  private handleError(error: any): Promise&lt;any&gt; {
    console.error(&#39;An error occurred: &#39;, error); // for demo only
    return Promise.reject(error.message || error);
  }


  getHero(id: number): Promise&lt;Hero&gt; {
    return this.getHeroes()
      .then(heroes =&gt; heroes.find(hero =&gt; hero.id === id))
  }

  create(name: string): Promise&lt;Hero&gt; {
    return this.http
      .post(this.heroesUrl, JSON.stringify({name: name}), {headers: this.headers})
      .toPromise()
      .then(res =&gt; res.json())
      .catch(this.handleError)
  }

  update(hero: Hero): Promise&lt;Hero&gt; {
    const url = `${this.heroesUrl}/${hero.id}`;
    return this.http
      .put(url, JSON.stringify(hero), {headers: this.headers})
      .toPromise()
      .then(() =&gt; hero)
      .catch(this.handleError);
  }

  delete(id: number): Promise&lt;void&gt; {
    console.log(`hero.service - deleting ${id}`);
    const url = `${this.heroesUrl}/${id}`;
    return this.http
      .delete(url, {headers: this.headers})
      .toPromise()
      .then(() =&gt; null)
      .catch(this.handleError);
  }
}</code></pre></div>

<p>Reload the app in your browser, and you should now see everything working - almost.
If you log in, everything works (yay!). </p>

<p>But we have two problems that we need to fix:</p>

<ul>
<li><p>If you hit the Dashboard or Heroes links without logging in first, you just get an error in the console, and no Heroes. It would be better to redirect to the login component.</p></li>
<li><p>It would actually be preferrable to not let the user access the Dashboard or Heroes links at all if they are not logged in.</p></li>
</ul>

<p>Let&#39;s fix the redirect problem first.
Edit dashboard.component.ts, and change it so that the application&#39;s Router is injected, and add error handling to navigate to the login page. The code should now look like this:</p>

<div><pre class="line-numbers"><code class="language-typescript">import { Component, OnInit } from &#39;@angular/core&#39;
import { Router } from &#39;@angular/router&#39;;

import { Hero } from &#39;./hero&#39;
import { HeroService } from &#39;./hero.service&#39;

@Component({
  moduleId: module.id,
  selector: &#39;my-dashboard&#39;,
  templateUrl: &#39;dashboard.component.html&#39;,
  styleUrls: [&#39;dashboard.component.css&#39;]
})
export class DashboardComponent implements OnInit {
  heroes: Hero[] = [];

  constructor(private router: Router, private heroService: HeroService) {
  }

  ngOnInit(): void {
    this.heroService.getHeroes()
      .then(
        heroes =&gt; this.heroes = heroes.slice(0, 4),
        error =&gt; {
          this.router.navigate([&#39;login&#39;]);
          console.error(&#39;An error occurred in dashboard component, navigating to login: &#39;, error);
        }
      );
  }
}</code></pre></div>

<p>Now, make the same changes to heroes.component.ts:</p>

<div><pre class="line-numbers"><code class="language-typescript">import { Component } from &#39;@angular/core&#39;;
import { OnInit } from &#39;@angular/core&#39;;
import { Router } from &#39;@angular/router&#39;;

import { Hero } from &#39;./hero&#39;;
import { HeroService } from &#39;./hero.service&#39;

@Component({
  moduleId: module.id,
  selector: &#39;my-heroes&#39;,
  templateUrl: &#39;heroes.component.html&#39;,
  styleUrls: [&#39;heroes.component.css&#39;],
  providers: [HeroService]

})
export class HeroesComponent implements OnInit {
    heroes: Hero[];
    selectedHero: Hero;

    constructor(private router: Router, private heroService: HeroService){ }

    ngOnInit(): void {
      this.getHeroes();
  }

    getHeroes(): void {
      this.heroService.getHeroes()
      .then(
        heroes =&gt; this.heroes = heroes,
        error =&gt; {
        this.router.navigate([&#39;login&#39;]);
        console.error(&#39;An error occurred in heroes component, navigating to login: &#39;, error);
        }
      )
  }


    onSelect(hero: Hero): void {
        this.selectedHero = hero;
    }

    gotoDetail(): void {
      this.router.navigate([&#39;/detail&#39;, this.selectedHero.id]);
  }

  add(name: string): void {
    name = name.trim();
    if(!name) { return; }
    this.heroService.create(name)
      .then(hero =&gt; {
        this.heroes.push(hero);
        this.selectedHero = null;
      });
  }

  delete(hero: Hero): void {
      this.heroService
      .delete(hero.id)
      .then(() =&gt; {
          this.heroes = this.heroes.filter(h =&gt; h !== hero);
          if(this.selectedHero === hero) {
            this.selectedHero = null;
        }
      });
  }
}</code></pre></div>

<p>Reload the application, and hit the Dashboard and Heroes links. Each time, you should see error messages in the browser&#39;s console indicating an error, and the app should navigate to the login page.</p>

<p>That&#39;s a nicer UI, and a good fall-back in case, say, the token expires, or something else goes wrong during the API call, but we should also prevent the user from attempting to access protected content when they&#39;re not logged in.</p>

<p>The answer for this is Angular 2 Auth Guards. An Auth Guard is a relatively simple class that makes one or more yes/no decisions about routing or module loading. We&#39;re interested in just one of those - the CanActivate function. </p>

<p>An AuthGuard can be applied to one or more of the routes in the application&#39;s routing module.</p>

<p>Our Authguard will simply check to see if the user is logged in (has an auth token in local storage). If the token is present, the route will proceed as usual. If the token is not present, the route will be blocked (an error is thrown), and the AuthGuard will navigate the UI to the /login route.</p>

<p>Add the following code to app/can-activate.authguard.ts:</p>

<div><pre class="line-numbers"><code class="language-typescript">import { Injectable } from &#39;@angular/core&#39;;
import { Router, CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot } from &#39;@angular/router&#39;;
import { AuthenticationService } from &#39;./authentication.service&#39;;

@Injectable()
export class CanActivateAuthGuard implements CanActivate {

  constructor(private router: Router, private authService: AuthenticationService) {}

  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {
        if (this.authService.isLoggedIn()) {
            // logged in so return true
            return true;
        }

        // not logged in so redirect to login page with the return url and return false
        this.router.navigate([&#39;/login&#39;]);
        return false;
    }
}</code></pre></div>

<p>Now, modify authentication.service.ts to add the isLoggedIn method:</p>

<div><pre class="line-numbers"><code class="language-typescript">isLoggedIn(): boolean {
  var token: String = getToken();
  return token &amp;&amp; token.length &gt; 0;
}</code></pre></div>

<p>Modify app.module.ts to register the Auth Guard as a provider:</p>

<div><pre class="line-numbers"><code class="language-typescript">import &#39;./rxjs-extensions&#39;;

import { NgModule }      from &#39;@angular/core&#39;;
import { BrowserModule } from &#39;@angular/platform-browser&#39;;
import { FormsModule } from &#39;@angular/forms&#39;;
import { HttpModule } from &#39;@angular/http&#39;;

import {AppRoutingModule} from &quot;./app-routing.module&quot;;

import { AppComponent }  from &#39;./app.component&#39;;
import { HomeComponent } from &#39;./home.component&#39;;
import { LoginComponent } from &#39;./login.component&#39;;
import { DashboardComponent } from &#39;./dashboard.component&#39;;
import { HeroesComponent } from &#39;./heroes.component&#39;;
import { HeroDetailComponent } from &#39;./hero-detail.component&#39;;
import { HeroService } from &#39;./hero.service&#39;;
import { HeroSearchComponent } from &#39;./hero-search.component&#39;;
import { AuthenticationService } from &#39;./authentication.service&#39;;
import { CanActivateAuthGuard } from &#39;./can-activate.authguard&#39;;

@NgModule({
  imports:      [
    BrowserModule,
      FormsModule,
    HttpModule,
    AppRoutingModule
  ],
  declarations: [
    AppComponent,
    HomeComponent,
    LoginComponent,
    DashboardComponent,
      HeroDetailComponent,
    HeroesComponent,
    HeroSearchComponent
  ],
  providers: [ HeroService, AuthenticationService, CanActivateAuthGuard ],
  bootstrap: [ AppComponent ]
})
export class AppModule {
}</code></pre></div>

<p>And finally, protect the routes that use the API by modifying app-routing.module.ts, importing CanActivateAuthGuard and applying to each of the routes that uses the API.</p>

<div><pre class="line-numbers"><code class="language-typescript">import { NgModule }             from &#39;@angular/core&#39;;
import { RouterModule, Routes } from &#39;@angular/router&#39;;
import { HomeComponent }        from &#39;./home.component&#39;;
import { LoginComponent }       from &#39;./login.component&#39;;
import { DashboardComponent }   from &#39;./dashboard.component&#39;;
import { HeroesComponent }      from &#39;./heroes.component&#39;;
import { HeroDetailComponent }  from &#39;./hero-detail.component&#39;;
import { CanActivateAuthGuard } from &#39;./can-activate.authguard&#39;;

const routes: Routes = [
  { path: &#39;&#39;, redirectTo: &#39;/home&#39;, pathMatch: &#39;full&#39; },
  { path: &#39;home&#39;,       component: HomeComponent },
  { path: &#39;login&#39;,      component: LoginComponent},
  { path: &#39;dashboard&#39;,  component: DashboardComponent, canActivate: [CanActivateAuthGuard]},
  { path: &#39;detail/:id&#39;, component: HeroDetailComponent, canActivate: [CanActivateAuthGuard] },
  { path: &#39;heroes&#39;,     component: HeroesComponent, canActivate: [CanActivateAuthGuard] }
];
@NgModule({
  imports: [ RouterModule.forRoot(routes) ],
  exports: [ RouterModule ]
})
export class AppRoutingModule {}</code></pre></div>

<p>By monitoring the browser&#39;s admin network window, you should see that when not logged in, you now get navigated to the the login view without making an API call first.</p>

<p>There&#39;s lots more that we could do to further polish this app, but this should give you a good playground for investigating Angular 2, Spring Security, and CORS, and provide a good basis for you to build a real, production app based on those technologies. </p>



<script type="text/javascript">
var _self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(){var e=/\blang(?:uage)?-(\w+)\b/i,t=0,n=_self.Prism={util:{encode:function(e){return e instanceof a?new a(e.type,n.util.encode(e.content),e.alias):"Array"===n.util.type(e)?e.map(n.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++t}),e.__id},clone:function(e){var t=n.util.type(e);switch(t){case"Object":var a={};for(var r in e)e.hasOwnProperty(r)&&(a[r]=n.util.clone(e[r]));return a;case"Array":return e.map&&e.map(function(e){return n.util.clone(e)})}return e}},languages:{extend:function(e,t){var a=n.util.clone(n.languages[e]);for(var r in t)a[r]=t[r];return a},insertBefore:function(e,t,a,r){r=r||n.languages;var l=r[e];if(2==arguments.length){a=arguments[1];for(var i in a)a.hasOwnProperty(i)&&(l[i]=a[i]);return l}var o={};for(var s in l)if(l.hasOwnProperty(s)){if(s==t)for(var i in a)a.hasOwnProperty(i)&&(o[i]=a[i]);o[s]=l[s]}return n.languages.DFS(n.languages,function(t,n){n===r[e]&&t!=e&&(this[t]=o)}),r[e]=o},DFS:function(e,t,a,r){r=r||{};for(var l in e)e.hasOwnProperty(l)&&(t.call(e,l,e[l],a||l),"Object"!==n.util.type(e[l])||r[n.util.objId(e[l])]?"Array"!==n.util.type(e[l])||r[n.util.objId(e[l])]||(r[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,l,r)):(r[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,null,r)))}},plugins:{},highlightAll:function(e,t){var a={callback:t,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};n.hooks.run("before-highlightall",a);for(var r,l=a.elements||document.querySelectorAll(a.selector),i=0;r=l[i++];)n.highlightElement(r,e===!0,a.callback)},highlightElement:function(t,a,r){for(var l,i,o=t;o&&!e.test(o.className);)o=o.parentNode;o&&(l=(o.className.match(e)||[,""])[1],i=n.languages[l]),t.className=t.className.replace(e,"").replace(/\s+/g," ")+" language-"+l,o=t.parentNode,/pre/i.test(o.nodeName)&&(o.className=o.className.replace(e,"").replace(/\s+/g," ")+" language-"+l);var s=t.textContent,u={element:t,language:l,grammar:i,code:s};if(!s||!i)return n.hooks.run("complete",u),void 0;if(n.hooks.run("before-highlight",u),a&&_self.Worker){var c=new Worker(n.filename);c.onmessage=function(e){u.highlightedCode=e.data,n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,r&&r.call(u.element),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},c.postMessage(JSON.stringify({language:u.language,code:u.code,immediateClose:!0}))}else u.highlightedCode=n.highlight(u.code,u.grammar,u.language),n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,r&&r.call(t),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},highlight:function(e,t,r){var l=n.tokenize(e,t);return a.stringify(n.util.encode(l),r)},tokenize:function(e,t){var a=n.Token,r=[e],l=t.rest;if(l){for(var i in l)t[i]=l[i];delete t.rest}e:for(var i in t)if(t.hasOwnProperty(i)&&t[i]){var o=t[i];o="Array"===n.util.type(o)?o:[o];for(var s=0;s<o.length;++s){var u=o[s],c=u.inside,g=!!u.lookbehind,h=!!u.greedy,f=0,d=u.alias;u=u.pattern||u;for(var p=0;p<r.length;p++){var m=r[p];if(r.length>e.length)break e;if(!(m instanceof a)){u.lastIndex=0;var y=u.exec(m),v=1;if(!y&&h&&p!=r.length-1){var b=r[p+1].matchedStr||r[p+1],k=m+b;if(p<r.length-2&&(k+=r[p+2].matchedStr||r[p+2]),u.lastIndex=0,y=u.exec(k),!y)continue;var w=y.index+(g?y[1].length:0);if(w>=m.length)continue;var _=y.index+y[0].length,P=m.length+b.length;if(v=3,P>=_){if(r[p+1].greedy)continue;v=2,k=k.slice(0,P)}m=k}if(y){g&&(f=y[1].length);var w=y.index+f,y=y[0].slice(f),_=w+y.length,S=m.slice(0,w),O=m.slice(_),j=[p,v];S&&j.push(S);var A=new a(i,c?n.tokenize(y,c):y,d,y,h);j.push(A),O&&j.push(O),Array.prototype.splice.apply(r,j)}}}}}return r},hooks:{all:{},add:function(e,t){var a=n.hooks.all;a[e]=a[e]||[],a[e].push(t)},run:function(e,t){var a=n.hooks.all[e];if(a&&a.length)for(var r,l=0;r=a[l++];)r(t)}}},a=n.Token=function(e,t,n,a,r){this.type=e,this.content=t,this.alias=n,this.matchedStr=a||null,this.greedy=!!r};if(a.stringify=function(e,t,r){if("string"==typeof e)return e;if("Array"===n.util.type(e))return e.map(function(n){return a.stringify(n,t,e)}).join("");var l={type:e.type,content:a.stringify(e.content,t,r),tag:"span",classes:["token",e.type],attributes:{},language:t,parent:r};if("comment"==l.type&&(l.attributes.spellcheck="true"),e.alias){var i="Array"===n.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(l.classes,i)}n.hooks.run("wrap",l);var o="";for(var s in l.attributes)o+=(o?" ":"")+s+'="'+(l.attributes[s]||"")+'"';return"<"+l.tag+' class="'+l.classes.join(" ")+'" '+o+">"+l.content+"</"+l.tag+">"},!_self.document)return _self.addEventListener?(_self.addEventListener("message",function(e){var t=JSON.parse(e.data),a=t.language,r=t.code,l=t.immediateClose;_self.postMessage(n.highlight(r,n.languages[a],a)),l&&_self.close()},!1),_self.Prism):_self.Prism;var r=document.currentScript||[].slice.call(document.getElementsByTagName("script")).pop();return r&&(n.filename=r.src,document.addEventListener&&!r.hasAttribute("data-manual")&&document.addEventListener("DOMContentLoaded",n.highlightAll)),_self.Prism}();"undefined"!=typeof module&&module.exports&&(module.exports=Prism),"undefined"!=typeof global&&(global.Prism=Prism);
</script>

<script type="text/javascript">
Prism.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\w\W]*?\*\//,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0}],string:{pattern:/(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,lookbehind:!0,inside:{punctuation:/(\.|\\)/}},keyword:/\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,"boolean":/\b(true|false)\b/,"function":/[a-z0-9_]+(?=\()/i,number:/\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,operator:/--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,punctuation:/[{}[\];(),.:]/};
</script>

<script type="text/javascript">
Prism.languages.javascript=Prism.languages.extend("clike",{keyword:/\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,number:/\b-?(0x[\dA-Fa-f]+|0b[01]+|0o[0-7]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|Infinity)\b/,"function":/[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\()/i}),Prism.languages.insertBefore("javascript","keyword",{regex:{pattern:/(^|[^\/])\/(?!\/)(\[.+?]|\\.|[^\/\\\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/,lookbehind:!0,greedy:!0}}),Prism.languages.insertBefore("javascript","class-name",{"template-string":{pattern:/`(?:\\\\|\\?[^\\])*?`/,greedy:!0,inside:{interpolation:{pattern:/\$\{[^}]+\}/,inside:{"interpolation-punctuation":{pattern:/^\$\{|\}$/,alias:"punctuation"},rest:Prism.languages.javascript}},string:/[\s\S]+/}}}),Prism.languages.markup&&Prism.languages.insertBefore("markup","tag",{script:{pattern:/(<script[\w\W]*?>)[\w\W]*?(?=<\/script>)/i,lookbehind:!0,inside:Prism.languages.javascript,alias:"language-javascript"}}),Prism.languages.js=Prism.languages.javascript;
</script>

<script type="text/javascript">
Prism.languages.typescript=Prism.languages.extend("javascript",{keyword:/\b(break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|get|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|set|static|super|switch|this|throw|true|try|typeof|var|void|while|with|yield|module|declare|constructor|string|Function|any|number|boolean|Array|enum)\b/});
</script>

<script type="text/javascript">
Prism.languages.css={comment:/\/\*[\w\W]*?\*\//,atrule:{pattern:/@[\w-]+?.*?(;|(?=\s*\{))/i,inside:{rule:/@[\w-]+/}},url:/url\((?:(["'])(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,selector:/[^\{\}\s][^\{\};]*?(?=\s*\{)/,string:/("|')(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1/,property:/(\b|\B)[\w-]+(?=\s*:)/i,important:/\B!important\b/i,"function":/[-a-z0-9]+(?=\()/i,punctuation:/[(){};:]/},Prism.languages.css.atrule.inside.rest=Prism.util.clone(Prism.languages.css),Prism.languages.markup&&(Prism.languages.insertBefore("markup","tag",{style:{pattern:/(<style[\w\W]*?>)[\w\W]*?(?=<\/style>)/i,lookbehind:!0,inside:Prism.languages.css,alias:"language-css"}}),Prism.languages.insertBefore("inside","attr-value",{"style-attr":{pattern:/\s*style=("|').*?\1/i,inside:{"attr-name":{pattern:/^\s*style/i,inside:Prism.languages.markup.tag.inside},punctuation:/^\s*=\s*['"]|['"]\s*$/,"attr-value":{pattern:/.+/i,inside:Prism.languages.css}},alias:"language-css"}},Prism.languages.markup.tag));
</script>

<script type="text/javascript">
Prism.languages.css.selector={pattern:/[^\{\}\s][^\{\}]*(?=\s*\{)/,inside:{"pseudo-element":/:(?:after|before|first-letter|first-line|selection)|::[-\w]+/,"pseudo-class":/:[-\w]+(?:\(.*\))?/,"class":/\.[-:\.\w]+/,id:/#[-:\.\w]+/}},Prism.languages.insertBefore("css","function",{hexcode:/#[\da-f]{3,6}/i,entity:/\\[\da-f]{1,8}/i,number:/[\d%\.]+/});
</script>

<script type="text/javascript">
Prism.languages.markup={comment:/<!--[\w\W]*?-->/,prolog:/<\?[\w\W]+?\?>/,doctype:/<!DOCTYPE[\w\W]+?>/,cdata:/<!\[CDATA\[[\w\W]*?]]>/i,tag:{pattern:/<\/?(?!\d)[^\s>\/=.$<]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\\1|\\?(?!\1)[\w\W])*\1|[^\s'">=]+))?)*\s*\/?>/i,inside:{tag:{pattern:/^<\/?[^\s>\/]+/i,inside:{punctuation:/^<\/?/,namespace:/^[^\s>\/:]+:/}},"attr-value":{pattern:/=(?:('|")[\w\W]*?(\1)|[^\s>]+)/i,inside:{punctuation:/[=>"']/}},punctuation:/\/?>/,"attr-name":{pattern:/[^\s>\/]+/,inside:{namespace:/^[^\s>\/:]+:/}}}},entity:/&#?[\da-z]{1,8};/i},Prism.hooks.add("wrap",function(a){"entity"===a.type&&(a.attributes.title=a.content.replace(/&amp;/,"&"))}),Prism.languages.xml=Prism.languages.markup,Prism.languages.html=Prism.languages.markup,Prism.languages.mathml=Prism.languages.markup,Prism.languages.svg=Prism.languages.markup;
</script>

<script type="text/javascript">
!function(e){var t={variable:[{pattern:/\$?\(\([\w\W]+?\)\)/,inside:{variable:[{pattern:/(^\$\(\([\w\W]+)\)\)/,lookbehind:!0},/^\$\(\(/],number:/\b-?(?:0x[\dA-Fa-f]+|\d*\.?\d+(?:[Ee]-?\d+)?)\b/,operator:/--?|-=|\+\+?|\+=|!=?|~|\*\*?|\*=|\/=?|%=?|<<=?|>>=?|<=?|>=?|==?|&&?|&=|\^=?|\|\|?|\|=|\?|:/,punctuation:/\(\(?|\)\)?|,|;/}},{pattern:/\$\([^)]+\)|`[^`]+`/,inside:{variable:/^\$\(|^`|\)$|`$/}},/\$(?:[a-z0-9_#\?\*!@]+|\{[^}]+\})/i]};e.languages.bash={shebang:{pattern:/^#!\s*\/bin\/bash|^#!\s*\/bin\/sh/,alias:"important"},comment:{pattern:/(^|[^"{\\])#.*/,lookbehind:!0},string:[{pattern:/((?:^|[^<])<<\s*)(?:"|')?(\w+?)(?:"|')?\s*\r?\n(?:[\s\S])*?\r?\n\2/g,lookbehind:!0,inside:t},{pattern:/(["'])(?:\\\\|\\?[^\\])*?\1/g,inside:t}],variable:t.variable,"function":{pattern:/(^|\s|;|\||&)(?:alias|apropos|apt-get|aptitude|aspell|awk|basename|bash|bc|bg|builtin|bzip2|cal|cat|cd|cfdisk|chgrp|chmod|chown|chroot|chkconfig|cksum|clear|cmp|comm|command|cp|cron|crontab|csplit|cut|date|dc|dd|ddrescue|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|du|egrep|eject|enable|env|ethtool|eval|exec|expand|expect|export|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|getopts|git|grep|groupadd|groupdel|groupmod|groups|gzip|hash|head|help|hg|history|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|jobs|join|kill|killall|less|link|ln|locate|logname|logout|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|make|man|mkdir|mkfifo|mkisofs|mknod|more|most|mount|mtools|mtr|mv|mmv|nano|netstat|nice|nl|nohup|notify-send|nslookup|open|op|passwd|paste|pathchk|ping|pkill|popd|pr|printcap|printenv|printf|ps|pushd|pv|pwd|quota|quotacheck|quotactl|ram|rar|rcp|read|readarray|readonly|reboot|rename|renice|remsync|rev|rm|rmdir|rsync|screen|scp|sdiff|sed|seq|service|sftp|shift|shopt|shutdown|sleep|slocate|sort|source|split|ssh|stat|strace|su|sudo|sum|suspend|sync|tail|tar|tee|test|time|timeout|times|touch|top|traceroute|trap|tr|tsort|tty|type|ulimit|umask|umount|unalias|uname|unexpand|uniq|units|unrar|unshar|uptime|useradd|userdel|usermod|users|uuencode|uudecode|v|vdir|vi|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yes|zip)(?=$|\s|;|\||&)/,lookbehind:!0},keyword:{pattern:/(^|\s|;|\||&)(?:let|:|\.|if|then|else|elif|fi|for|break|continue|while|in|case|function|select|do|done|until|echo|exit|return|set|declare)(?=$|\s|;|\||&)/,lookbehind:!0},"boolean":{pattern:/(^|\s|;|\||&)(?:true|false)(?=$|\s|;|\||&)/,lookbehind:!0},operator:/&&?|\|\|?|==?|!=?|<<<?|>>|<=?|>=?|=~/,punctuation:/\$?\(\(?|\)\)?|\.\.|[{}[\];]/};var a=t.variable[1].inside;a["function"]=e.languages.bash["function"],a.keyword=e.languages.bash.keyword,a.boolean=e.languages.bash.boolean,a.operator=e.languages.bash.operator,a.punctuation=e.languages.bash.punctuation}(Prism);
</script>

<script type="text/javascript">
Prism.languages.sql={comment:{pattern:/(^|[^\\])(?:\/\*[\w\W]*?\*\/|(?:--|\/\/|#).*)/,lookbehind:!0},string:{pattern:/(^|[^@\\])("|')(?:\\?[\s\S])*?\2/,lookbehind:!0},variable:/@[\w.$]+|@("|'|`)(?:\\?[\s\S])+?\1/,"function":/\b(?:COUNT|SUM|AVG|MIN|MAX|FIRST|LAST|UCASE|LCASE|MID|LEN|ROUND|NOW|FORMAT)(?=\s*\()/i,keyword:/\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR VARYING|CHARACTER (?:SET|VARYING)|CHARSET|CHECK|CHECKPOINT|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMN|COLUMNS|COMMENT|COMMIT|COMMITTED|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS|CONTAINSTABLE|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|DATA(?:BASES?)?|DATETIME|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE(?: PRECISION)?|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE KEY|ELSE|ENABLE|ENCLOSED BY|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPE(?:D BY)?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|IDENTITY(?:_INSERT|COL)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTO|INVOKER|ISOLATION LEVEL|JOIN|KEYS?|KILL|LANGUAGE SQL|LAST|LEFT|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MODIFIES SQL DATA|MODIFY|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL(?: CHAR VARYING| CHARACTER(?: VARYING)?| VARCHAR)?|NATURAL|NCHAR(?: VARCHAR)?|NEXT|NO(?: SQL|CHECK|CYCLE)?|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READ(?:S SQL DATA|TEXT)?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEATABLE|REPLICATION|REQUIRE|RESTORE|RESTRICT|RETURNS?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE MODE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|START(?:ING BY)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED BY|TEXT(?:SIZE)?|THEN|TIMESTAMP|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNPIVOT|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?)\b/i,"boolean":/\b(?:TRUE|FALSE|NULL)\b/i,number:/\b-?(?:0x)?\d*\.?[\da-f]+\b/,operator:/[-+*\/=%^~]|&&?|\|?\||!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|IN|LIKE|NOT|OR|IS|DIV|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,punctuation:/[;[\]()`,.]/};
</script>

<script type="text/javascript">
Prism.languages.java=Prism.languages.extend("clike",{keyword:/\b(abstract|continue|for|new|switch|assert|default|goto|package|synchronized|boolean|do|if|private|this|break|double|implements|protected|throw|byte|else|import|public|throws|case|enum|instanceof|return|transient|catch|extends|int|short|try|char|final|interface|static|void|class|finally|long|strictfp|volatile|const|float|native|super|while)\b/,number:/\b0b[01]+\b|\b0x[\da-f]*\.?[\da-fp\-]+\b|\b\d*\.?\d+(?:e[+-]?\d+)?[df]?\b/i,operator:{pattern:/(^|[^.])(?:\+[+=]?|-[-=]?|!=?|<<?=?|>>?>?=?|==?|&[&=]?|\|[|=]?|\*=?|\/=?|%=?|\^=?|[?:~])/m,lookbehind:!0}}),Prism.languages.insertBefore("java","function",{annotation:{alias:"punctuation",pattern:/(^|[^.])@\w+/,lookbehind:!0}});
</script>

<script type="text/javascript">
Prism.languages.groovy=Prism.languages.extend("clike",{keyword:/\b(as|def|in|abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|native|new|package|private|protected|public|return|short|static|strictfp|super|switch|synchronized|this|throw|throws|trait|transient|try|void|volatile|while)\b/,string:/("""|''')[\W\w]*?\1|("|'|\/)(?:\\?.)*?\2|(\$\/)(\$\/\$|[\W\w])*?\/\$/,number:/\b(?:0b[01_]+|0x[\da-f_]+(?:\.[\da-f_p\-]+)?|[\d_]+(?:\.[\d_]+)?(?:e[+-]?[\d]+)?)[glidf]?\b/i,operator:{pattern:/(^|[^.])(~|==?~?|\?[.:]?|\*(?:[.=]|\*=?)?|\.[@&]|\.\.<|\.{1,2}(?!\.)|-[-=>]?|\+[+=]?|!=?|<(?:<=?|=>?)?|>(?:>>?=?|=)?|&[&=]?|\|[|=]?|\/=?|\^=?|%=?)/,lookbehind:!0},punctuation:/\.+|[{}[\];(),:$]/}),Prism.languages.insertBefore("groovy","string",{shebang:{pattern:/#!.+/,alias:"comment"}}),Prism.languages.insertBefore("groovy","punctuation",{"spock-block":/\b(setup|given|when|then|and|cleanup|expect|where):/}),Prism.languages.insertBefore("groovy","function",{annotation:{alias:"punctuation",pattern:/(^|[^.])@\w+/,lookbehind:!0}}),Prism.hooks.add("wrap",function(e){if("groovy"===e.language&&"string"===e.type){var t=e.content[0];if("'"!=t){var n=/([^\\])(\$(\{.*?\}|[\w\.]+))/;"$"===t&&(n=/([^\$])(\$(\{.*?\}|[\w\.]+))/),e.content=e.content.replace(/&amp;/g,"&").replace(/&lt;/g,"<"),e.content=Prism.highlight(e.content,{expression:{pattern:n,lookbehind:!0,inside:Prism.languages.groovy}}),e.classes.push("/"===t?"regex":"gstring")}}});
</script>

<script type="text/javascript">
!function(){"undefined"!=typeof self&&self.Prism&&self.document&&Prism.hooks.add("complete",function(e){if(e.code){var t=e.element.parentNode,s=/\s*\bline-numbers\b\s*/;if(t&&/pre/i.test(t.nodeName)&&(s.test(t.className)||s.test(e.element.className))&&!e.element.querySelector(".line-numbers-rows")){s.test(e.element.className)&&(e.element.className=e.element.className.replace(s,"")),s.test(t.className)||(t.className+=" line-numbers");var n,a=e.code.match(/\n(?!$)/g),l=a?a.length+1:1,m=new Array(l+1);m=m.join("<span></span>"),n=document.createElement("span"),n.className="line-numbers-rows",n.innerHTML=m,t.hasAttribute("data-start")&&(t.style.counterReset="linenumber "+(parseInt(t.getAttribute("data-start"),10)-1)),e.element.appendChild(n)}}})}();
</script>


</body>

</html>
